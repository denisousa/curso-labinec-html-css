"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomUUID = exports.randomEnglish = exports.randomLatin = exports.randomCaseString = exports.randomAZString = exports.randomString = exports.randomInRange = exports.random = exports.randomWords = exports.azString = exports.setRange = exports.flexRange = exports.coinFlip = void 0;
const crypto_1 = __importDefault(require("crypto"));
const util_1 = require("../util");
// DATA IMPORT
const _256Latin_1 = __importDefault(require("../data/256Latin"));
const _182English_1 = __importDefault(require("../data/182English"));
const { asUpper, asLower } = require('../data/letters');
// INTERNAL
function foundation(base) {
    const byteCount = makeByteCount(base);
    return promiseCryptoRBytes(byteCount)
        .then((buf) => buf.toString('hex'));
}
function numberFoundation(base) {
    const trueBase = Math.abs(base);
    return foundation(trueBase)
        .then((hex) => {
        const val = parseInt(hex, 16);
        if (trueBase === 1) {
            return val % 2;
        }
        else {
            return val % trueBase;
        }
    });
}
function stringFoundation(base) {
    const trueBase = Math.abs(base);
    return promiseCryptoRBytes(trueBase)
        .then((buf) => buf.toString('hex'));
}
function promiseCryptoRBytes(byteCount = 1) {
    return new Promise((resolve, reject) => {
        crypto_1.default.randomBytes(byteCount, (err, buf) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(buf);
            }
        });
    });
}
function makeByteCount(max) {
    let ret = 1;
    let cycle = 256;
    while (max > cycle) {
        cycle *= 256;
        ret++;
    }
    if (ret == 1)
        ret++;
    return ret;
}
async function randomLetter(count = 3, source) {
    let ret = '';
    for (let i = 0; i < count; i++) {
        const index = await numberFoundation(25);
        ret += source[index];
    }
    return ret;
}
// EXTERNAL
function random(v = 1) {
    const pureV = (0, util_1.cleanInteger)(v, 1);
    return numberFoundation(pureV)
        .then(res => (pureV < 0 && res !== 0) ? res * -1 : res);
}
exports.random = random;
function coinFlip() {
    return random()
        .then(num => num === 0);
}
exports.coinFlip = coinFlip;
function randomInRange(v1 = -100, v2 = 100) {
    v1 = (0, util_1.cleanInteger)(v1, -100);
    v2 = (0, util_1.cleanInteger)(v2, 100);
    let high = 0;
    let low = 0;
    if (v1 < v2) {
        high = v2;
        low = v1;
    }
    else if (v1 > v2) {
        high = v1;
        low = v2;
    }
    else {
        return random(v2);
    }
    const baseValue = high - low;
    return numberFoundation(baseValue)
        .then(res => (baseValue < 0) ? (res * -1) + low : res + low);
}
exports.randomInRange = randomInRange;
function randomAZString(len = 10, upper = true) {
    len = (0, util_1.cleanInteger)(len, 10);
    if (upper) {
        return randomLetter(len, asUpper);
    }
    else {
        return randomLetter(len, asLower);
    }
}
exports.randomAZString = randomAZString;
function randomString(len = 10) {
    len = (0, util_1.cleanInteger)(len, 10);
    return stringFoundation(len)
        .then(hex => hex.slice(0, len));
}
exports.randomString = randomString;
function randomCaseString(len = 10) {
    len = (0, util_1.cleanInteger)(len, 10);
    return stringFoundation(len)
        .then(hex => hex.slice(0, len))
        .then(async (str) => {
        return Promise.all(str
            .split('')
            .map(async (char) => (await coinFlip()) ? char : char.toUpperCase()));
    })
        .then(strArr => strArr.join(''));
}
exports.randomCaseString = randomCaseString;
async function randomLatin(len = 5) {
    len = (0, util_1.cleanInteger)(len, 5);
    let ret = [];
    for (let i = 0; i < len; i++) {
        const index = await numberFoundation(255);
        ret.push(_256Latin_1.default[index]);
    }
    return ret.join(' ');
}
exports.randomLatin = randomLatin;
async function randomEnglish(len = 5) {
    len = (0, util_1.cleanInteger)(len, 5);
    let ret = [];
    for (let i = 0; i < len; i++) {
        const index = await numberFoundation(181);
        ret.push(_182English_1.default[index]);
    }
    return ret.join(' ');
}
exports.randomEnglish = randomEnglish;
async function randomUUID() {
    return stringFoundation(16)
        .then(res => {
        const byteTo4 = res.slice(12, 14);
        const maskOr = parseInt('01000000', 2);
        const maskAnd = parseInt('01001111', 2);
        const byteSet4 = (maskOr | (maskAnd & parseInt(byteTo4, 16)));
        return res.slice(0, 12) + byteSet4.toString(16) + res.slice(14);
    })
        .then(res => {
        const bytePart2 = res.slice(16, 18);
        const maskOr = parseInt('10000000', 2);
        const maskAnd = parseInt('10111111', 2);
        const byteSetPart2 = (maskOr | (maskAnd & parseInt(bytePart2, 16)));
        return res.slice(0, 16) + byteSetPart2.toString(16) + res.slice(18);
    })
        .then(res => {
        return [
            res.slice(0, 8),
            res.slice(8, 12),
            res.slice(12, 16),
            res.slice(16, 20),
            res.slice(20),
        ].join("-").toUpperCase();
    });
}
exports.randomUUID = randomUUID;
// WRAPPERS
function flexRange(v) {
    return random(v);
}
exports.flexRange = flexRange;
function setRange(v1, v2) {
    return randomInRange(v1, v2);
}
exports.setRange = setRange;
function azString(len, upper) {
    return randomAZString(len, upper);
}
exports.azString = azString;
function randomWords(len) {
    return randomLatin(len);
}
exports.randomWords = randomWords;
//# sourceMappingURL=index.js.map